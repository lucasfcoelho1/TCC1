%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% CAPÍTULO 2
\chapter{FUNDAMENTAÇÃO TEÓRICA}  




\section{Teste de software}
O processo de teste de um software pode ser dividido em quatro etapas: planejamento dos testes, projetar os casos de testes, execução e avaliação dos resultados \cite{myers197977ie10, beizer1990software11,maldonado1991criterios4, Pressman20093}. Essas quatro etapas fazem parte do processo de desenvolvimento do software e geralmente são compostas por três fases: o teste de unidade, de integração e de sistema. Na primeira fase, o teste de unidade, os desenvolvedores concentram-se na menor parte do sistema separadamente, a unidade, que no caso de uma linguagem de programação que tenha o paradigma de Orientação a Objetos, a menor parte pode ser um método. O teste de integração visa identificar problemas na integração dessas unidades, testando a interdependência dos métodos e interfaces. No teste de sistema, feito somente após o dois anteriores, testa-se a usabilidade do sistema como um todo, verificando se há algum defeito na criação das interfaces ou se houve algum erro na especificação anteriormente validada com o cliente \cite{Pressman20093}. Existem várias técnicas e critérios para realizar testes de software e elas podem ser divididas em dois grupos: técnica funcional e técnica estrutural. Na funcional que também é conhecido como teste caixa preta \cite{myers197977ie10}, isso se dá pelo fato de que o sistema é observado como se fosse uma caixa fechada, podendo-se observar apenas os lados de fora. Nesse caso o testador insere dados e observa se a saída condiz com o que foi especificado, não se preocupando com os detalhes da implementação daquela funcionalidade. Portanto é fundamental que a especificação tenha sido bem elaborada. Alguns exemplos de critérios de teste funcional são: Particionamento em Classes de Equivalência, Análise do Valor Limite e Grafo de Causa-Efeito \cite{Pressman20093}. Já a técnica estrutural, conhecida como caixa branca \cite{Pressman20093}, vem para complementar à técnica funcional, já que o desenvolvedor tem total acesso ao código, utilizando-o para elaborar os testes de acordo com a própria lógica interna do programa. Alguns exemplos de critérios de teste estrutural são: Grafo de Fluxo de Controle, Grafo de fluxo de dados e Teste de Mutação.

\section{Aplicações Móveis}

Existem várias formas para desenvolver aplicativos para as plataformas móveis e podem ser classificadas em três grupos: aplicações nativas, aplicações Web e aplicações híbridas \cite{Maldonado2004}. 
Aplicações nativas são desenvolvidos para uma plataforma específica. A forma de desenvolvimento é definida pala organização proprietária. Esta empresa fornece para os desenvolvedores o \textit{Software Development Kit} (SDK) e uma \textit{Integrated Development Environment} (IDE), que é o conjunto de ferramentas necessárias para desenvolver um aplicativo para a aquela plataforma. Ao optar por uma aplicação nativa o desenvolvedor tem acesso a todas as \textit{Application Programming Interface} (API) para aquele SO sem restrições. A desvantagem de desenvolver nativamente é que a aplicação fica restrita a uma única plataforma, tendo que reescrever todo o programa caso seja necessário publicar o mesmo aplicativo em outras lojas. 
Aplicações Web são desenvolvidas utilizando as mesmas tecnologias que são utilizadas na Web, como HTML5 \cite{HTML5}, CSS3 \cite{CSS3}e JavaScript \cite{ECMA}. Essas aplicações não são instaladas no dispositivo, executam num servidor Web e são desenvolvidas de forma que se adaptem as diferentes resoluções dos computadores, \textit{smartphones} e \textit{tablets}. Como são executas em um navegar Web não possuem um acesso tão avançado as APIs nativas dos dispositivos. 

Aplicações hibridas, também chamadas de \textit{cross-platform} (multiplataforma) são \textit{frameworks} de desenvolvimento que abstraem todo o modo de desenvolvimento de aplicativos, utilizando apenas o que o \textit{framework} fornece é possível criar aplicações para os SOs mais comuns do mercado. Essas aplicações híbridas são divididas em duas amplas classes. A primeira que é chamada de \textit{Web-based framework} \cite{7372032}, onde permitem que os desenvolvedores utilizem as linguagens Web, como HTML5, CSS3 e JavaScript. Exemplos de \textit{Web-based frameworks} são o Adobe PhoneGap \cite{Adobe}, Apache Cordova \cite{Apache}, IBM MobileFirst \cite{IBM}, IONIC \cite{IONIC}. Os desenvolvedores utilizam as linguagens Web para criar a lógica de aplicação e a interface do usuário. Contudo essas linguagens não suportam totalmente todos os recursos dos dispositivos como câmera, microfone, agenda de contatos e preferências do telefone. Portanto para utilizar essas ferramentas os \textit{frameworks} fornecem bibliotecas que são utilizadas em tempo de execução para acessar os recursos de hardware, por isso são popularmente chamados de aplicações híbridas. Entretanto com esses \textit{frameworks} não é possível criar aplicações de alto desempenho como jogos ou algo que utilize animação. Outro problema é que toda a interface é feita nas linguagens da Web, então alguns controles que ainda não estejam implementados podem aparecer diferentes dos controles nativos, ficando claro para o usuário que aquele aplicativo não foi desenvolvido de forma nativa.

A segunda classe é chamada de \textit{native framework}. Alguns exemplos de \textit{frameworks} são o Facebook React Native \cite{Facebook}, Apportable \cite{Apportable}, MyAppConverter \cite{MyAppConverter} e o Xamarin \cite{Xamarin}. A diferença para os \textit{frameworks} mostrados acima é que os \textit{native frameworks} utilizam tudo do SO nativamente. Todo o aplicativo é construído em uma linguagem e ao ser compilado para outra plataforma alvo o \textit{framework} consome todas as APIs nativas. Por exemplo ao escrever uma aplicação em Xamarin os desenvolvedores utilizam a linguagem C\# \cite{CSharp2017} para criar a lógica de negócio e XAML \cite{XAML2017} para a interface de usuário. No processo de compilação todo o código XAML será interpretado e renderizado de acordo com a plataforma e versão de SO selecionados, chamando os controles nativos.

\section{Xamarin}

Xamarin é um \textit{framework} de desenvolvimento para dispositivos móveis \textit{cross-plataform} e mantido pela Microsoft \cite{Microsoft2017}. O \textit{framework} Xamarin possui três técnicas diferentes para criar aplicações móveis: Xamarin.iOS \cite{Xamarin.iOS2017}, Xamarin.Android \cite{Xamarin.Android2017} e Xamarin.Forms \cite{Xamarin.Forms2017}.

\subsection{Xamarin.iOS e Xamarin.Android}

Ambos são criados sobre o Mono \cite{Mono2017}, uma versão de software livre do .NET Framework \cite{.NetFramework2017}. Os aplicativos feitos em uma dessas duas técnicas, ficam limitados a plataforma escolhida. Por exemplo, caso o desenvolvedor escolha o Xamarin.Android, nenhuma tela que foi criada para interação do usuário será reaproveitada quando o time de desenvolvimento decidir fazer o mesmo aplicativo para iOS, obrigando o os desenvolvedores recriarem toda a interface e lógica de apresentação, reaproveitado apenas a lógica de aplicação, como pode ser visto na Figura 1.

Figura 1: Arquitetura de desenvolvimento de aplicativos Xamarin.Android e Xamarin.iOS
Fonte: (site)

Na figura 1, é possível notar que todo o código da lógica da aplicação é escrito em C\# e utilizado em todas as plataformas (Shared C\# App Logic), contudo a para cada uma das plataformas será necessário recriar a lógica de apresentação (Plataform-specific C\#).
Os aplicativos são escritos na linguagem C\# e compilados e utilizando a versão específica da DLL (Dynamic-link Library) de acordo com a plataforma. No caso, MonoTouch.dll [20] para iOS e MonoAndroid.dll [21] para Android. Após o processo de compilação o resultado é um pacote de aplicação idêntico aos que são feitos nas IDEs padrão, sendo impossível distinguir um .apk feito em Android Studio e outro feito em Xamarin.

\subsection{Xamarin.Forms}
O Xamarin.Forms é uma abstração da forma de criar aplicações móveis, utilizando essa tecnologia é possível escrever um único código que será interpretado e compilado individualmente em cada plataforma. As interfaces de usuário são renderizadas e transformadas em controles nativos. Diferente do Xamarin.Android e Xamarin.iOS que apenas a lógica de aplicação é compartilhada, no Xamarin.Forms tanto a interface quanto a própria lógica de aplicação são escritas uma única vez. Quando um aplicativo é compilado ele utiliza a API nativa de cada plataforma. O Xamarin.Forms visa trazer agilidade para os times de desenvolvimento, sendo necessário que todos conheçam apenas uma linguagem de programação. Além disso, caso tenha algum problema ou o time decida fazer alguma melhoria, basta atualizar apenas uma base de código. Como é mostrado na Figura 2, tanto a lógica de aplicação (Shared C\# App Logic) quanto a lógica de apresentação e interface (Shared C\# User Interface Code).

Figura 2: Arquitetura de desenvolvimento de aplicativos Xamarin.Forms
Fonte (site)

Para exemplificar a utilização do Xamarin.Forms será utilizado um projeto de cálculo de Índice de Massa Corporal (IMC). O IMC é o resultado de uma fórmula matemática que indica como a sua saúde em relação a sua massa corporal, contudo esse índice é apenas um ponto de partida, já que o IMC não define exatamente o seu estado nutricional. A fórmula para realizar o cálculo é: IMC = P (peso em quilos)/A (altura x altura, em metros) [25]. Lembrando que o IMC somente é válido para pessoas adultas e com idades entre 20 a 59 anos. A aplicação desenvolvida é composta de apenas uma tela que possuem duas entradas de dados, a primeira é a altura que deve ser inserida pela medida de uma pessoa adulta, e em metros. A próxima entrada é o peso que deve ser informado em quilogramas. Os dois controles aceitam somente números que podem conter casas decimais. Logo abaixo existe o botão ?CALCULAR?, que chamará o método da fórmula do cálculo e passará os dois valores como parâmetro. Caso nenhum dos campos tenham valores em branco, nulos ou zeros, ao clicar no botão o aplicativo exibirá o resultado do cálculo e um texto informando em qual das faixas de peso a pessoa está enquadrada. Os possíveis resultados são:
Baixo peso: Caso o resultado seja menor que 18,5.
Peso adequado: Caso o resultado seja maior ou igual a 18,5 e menor que 25.
Sobrepeso: Caso o resultado seja maior ou igual a 25 e menor que 30.
Obesidade: Caso o resultado seja maior ou igual a 30.

Figura 3: Aplicativo exemplo ? Tela inicial 
Fonte: Autoria própria

\subsection{Estrutura do projeto}
A IDE necessária para codificar uma aplicação Xamarin é o Xamarin Studio [26] no Apple Mac OS [27] e o Visual Studio [28] no Microsoft Windows [29]. Para desenvolver este exemplo foi utilizado um computador com Microsoft Windows 10 e o Visual Studio na versão 2017.
Um projeto Xamarin.Forms é um conjunto de projetos, denominado Solution e é composto por no mínimo quatro projetos: Um Portable, um Android, um iOS e outro UWP. Todo o código será escrito no projeto Portable e quando for executar a saída será necessário compilar cada projeto individualmente para a plataforma desejada. Caso seja necessário utilizar algum recurso muito específico de alguma das plataformas será necessário criar um código dentro do projeto de cada uma delas, já que o que não estiver na Portable não será compartilhado com os outros projetos.
O projeto foi desenvolvido utilizando o padrão Model View ViewModel (MVVM) [30], criado pela Microsoft e era anteriormente utilizado pelo WPF [31] e Silverlight [32]. Este padrão visa separar as responsabilidades dos objetos. A View é a interface do usuário e a sua única função é exibir os controles, como botões ou textos. A Model é onde fica toda a lógica de negócio e os dados, os métodos de acesso a banco de dados geralmente estão nas Models. A ViewModel faz a ligação entre esses dois objetos, afinal a View e a Model não estão relacionadas diretamente, não sendo possível. Na ViewModel é programada toda a lógica de apresentação. A comunicação com a View é feita através dos databindings. Ao escrever o XAML da View, pode-se associar um controle da interface à uma propriedade da ViewModel, com o databinding, a vantagem disso é que qualquer alteração que for feita em qualquer um dos arquivos, seja por interação do usuário na interface ou por algum cálculo feito internamente na ViewModel, a propriedade será notificada e alterada, não sendo necessário utilizar eventos para monitorar as ações do usuário. Caso o time de desenvolvimento seja bem separado e bem definido, ainda é possível que a View e a ViewModel sejam programadas por pessoas ou times diferentes, um deles cuidando apenas do XAML da View e outro criando os métodos na classe C\# da ViewModel, basta que apenas o time que criará a View descreva em detalhes o que será exibido ao usuário e qual o seu comportamento. Uma outra vantagem de ter toda a lógica de apresentação na ViewModel é que isso torna o código completamente testável, uma vez que uma ViewModel nada mais é do que uma simples classe e totalmente compatível com qualquer framework de testes automatizados que suportem a linguagem C\#.
É uma boa prática de programação dividir as responsabilidades em pastas, a título de organização. Como é possível ver na imagem a seguir as ViewModels do projeto são classes C\# e cada View é um arquivo com extensão .XAML e que possui também uma classe C\# relacionada a View, chamada de code-behind. No code-behind também é possível escrever toda a lógica de apresentação, contudo isso cria um acoplamento muito forte entre a View e o seu respectivo code-behind, caso em algum momento o time de desenvolvimento precise remover uma View ou alterar a sua ordem ou lógica de apresentação, será necessário refatorar todo o código, procurando por dependências. Já a ViewModel que como possui um baixo acoplamento com as Views podem ser separadas a qualquer momento. Nesse exemplo temos a View MainPage.xaml e MainPage.xaml.cs que é o seu code-behind. Por questões de organização as ViewModels que contém a lógica de apresentação da View, recebem o mesmo nome e no final acrescenta-se ?ViewModel?, como no exemplo temos a MainPage o nome da nossa ViewModel será MainPageViewModel.cs Existe também a BaseViewModel; essa classe tem a abstração de alguns métodos ou atributos que serão utilizados em todas as outras ViewModels.

Figura 4: Estrutura de arquivos do projeto
Fonte: Autoria própria

O arquivo App.xaml apesar de ter as mesmas propriedades de uma view, como a extensão XAML e o code-behind, ela é apenas um objeto que extrai os métodos de ciclo de vida dos aplicativos, como é possível ver na figura 5:

Figura 5: Trecho de código da classe App.xaml.cs
Fonte: Autoria própria

Através dos métodos da classe App.xaml.cs é possível controlar os comportamentos de ciclo de vida da aplicação em cada uma das plataformas. Caso seja inserida alguma lógica de apresentação no método OnStart(), está será a primeira coisa a ser executada assim que o aplicativo for iniciado. No OnSleep() a programação só terá efeito quando o aplicativo for colocado em segundo plano, quando o usuário navegar por outro aplicativo por exemplo. Já o OnResume() só será executado quando o aplicativo voltar a ficar ativo, em primeiro plano. 
A plicação é iniciada na classe App.xaml.cs, onde é instanciado o primeiro objeto, no método construtor da classe. MainPage é a primeira página da aplicação e no caso atribuímos uma NavigationPage e passando MainPage como parâmetro. Utilizando o NavigationPage é permitido fazer uso da navegação por pilha, presente em todas as plataformas mobile, onde a cada nova tela aberta o SO empilha a nova tela sobre a anterior e quando o usuário realiza a ação para voltar, ele desempilha e destrói aquela tela, podendo desempilhar até chegar a tela inicial, a MainPage.  

Figura 6: Trecho de código da View MainPage.xaml
Fonte: Autoria própria

Na figura 6 é mostrado o conteúdo de um arquivo XAML. Toda a interface do usuário é escrita neste arquivo, utilizando da abstração do Xamarin.Forms ao inserir a tag <Button>, na linha 20, o Xamarin transformará em tempo de compilação essa tag em um controle, invocando a API nativa referente a um botão, de acordo com a plataforma para qual estiver desenvolvendo. É possível notar que alguns controles, como os as entradas de texto das linhas 17 e 19, foi utilizado o conceito de databindings, presente no Xamarin.Forms. Com isso ao inserir ou alterar um valor novo no campo, como ele está ligado a uma propriedade de uma classe, não é necessário monitorar as alterações desse controle, já que todas as mudanças serão automaticamente refletidas na classe. Quase todos os atributos de uma tag podem ser definidas por databindings, não se limitando apenas a textos ou números. Por exemplo o controle de interface StackLayout, da linha 23, ele é responsável por agrupar elementos de interface. Ele possui uma propriedade IsVisible da qual o valor está associado a uma propriedade booleana da classe, podendo receber verdadeiro ou falso, ou seja, dependendo da lógica de apresentação, o StackLayout pode ou não estar visível. Neste exemplo do IMC se os valores de altura (Height) ou peso (Weight) forem igual a zero e o usuário clicar no botão para fazer o cálculo, a propriedade IsVisible recebe o valor false e o elemento deixa de ser exibido na tela.

Figura 6: Trecho de código da classe MainPage.xaml.cs
Fonte: Autoria própria

A figura 7 contém todo o código do code-behind da View MainPage.xaml. Como toda a lógica de apresentação deve estar contida em uma ViewModel, a única instrução que a classe executa é informar qual é o seu BindingContext na linha 16, ou seja, qual a classe que a View deve associar as suas propriedades.

Figura 8: trecho de código da classe BaseViewModel.cs
Fonte: Autoria própria

Na figura 8 é mostrado o código da BaseViewModel.cs, uma classe onde abstrai os métodos e propriedades que serão utilizados nas demais ViewModels. Para tirar trabalhar com os databindings é necessário que seja implementada a interface INotifyPropertyChanged, na linha 11. Nessa interface temos o evento PropertyChangedEcentHandler, na linha 15 que junto com o método OnPropertyChanged(), na linha 17, é responsável por monitorar as propriedades e informar quando elas foram alteradas. Já na linha 22 temos o método SetProperty(), que deve ser incluído nos métodos setters das propriedades das ViewModels. Nele é executada a verificação para garantir que haja a mudança do valor apenas quando a propriedade for alterada, economizando processamento desnecessário do dispositivo.

Figura 9: Trecho de código da classe MainPageViewModel.cs
Fonte: Autoria própria

No trecho de código da figura 9 a classe MainPageViewModel.cs implementa a BaseViewModel.cs. Quando definimos as propriedades da classe, todas as que terão alguma alteração na exibição para o usuário devem chamar o método SetProperty() nos seus métodos setters. Só assim o Xamarin garante que o valor será sempre o mesmo, em qualquer um dos arquivos, sem que seja necessário criar um evento na interface que verifique se os valores foram alterados. Todas essas propriedades estão ligadas a um controle na View.

Figura 10: Trecho de código da classe MainPageViewModel.cs
Fonte: Autoria própria

A figura 10 exibe toda a lógica de apresentação da MainPageViewModel.cs para a MainPage.xaml. No construtor são definidos os parâmetros inicias para a execução da aplicação. A propriedade IsVisible é iniciada com falso, ocultando o controle de layout da View, já que no início da aplicação nenhum cálculo foi executado e sendo assim não há nada a ser exibido. O CalculateCommand é a propriedade do tipo Command, presente framework Xamarin.Forms, que é associado a um método o ExecuteCommandCalculate() e é nele onde é executado a lógica para a ação do botão ?CALCULAR? da interface, que também está ligado a classe por databindings. 
O método verifica primeiramente se as propriedades Height e Weight estão com valor zero, se verdadeiro, IsVisible recebe false e o método termina, caso contrário o valor a ser atribuído será true e os valores de altura e peso serão calculados na fórmula. Para cada um dos valores existe uma saída em texto correspondente que será atribuído à propriedade Message, que está contida no controle StackLayout.

\section{Appium}

Appium é um \textit{framework open source}  para automatizar testes em aplicativos \textit{mobile}. Com ele é possível testar \textit{apps} nativas, híbridas e \textit{apps} Web. Além disso, ele é \textit{cross-platform}, possibilitando realizar testes automatizados nas plataformas iOS e Android, utilizando o Selenium WebDriver API[]. O testador utilizando o Appium consegue gerar \textit{scripts} de teste que são gravados, gerando um projeto para o Microsoft Visual Studio, codificado em C\# do qual também tem suporte para o Unit Testing Framework []. O projeto possui uma estrutura que pode ser utilizado para testar a mesma \textit{app} em diversas configurações diferentes. Inclusive o \textit{framework} é compatível com ambientes de teste em nuvem como o Amazon Device Farm [], Bitbar [] e TestObject []. Estas plataformas disponibilizam uma grande quantidade de dispositivos reais dos quais é possível instalar as \textit{apps} e validar o comportamento nas mais variadas configurações possíveis como resoluções de tela, diferentes SOs e capacidade de recursos disponíveis no dispositivo.


